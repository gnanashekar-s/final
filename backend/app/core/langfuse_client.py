# Code Generated by Sidekick is for learning and experimentation purposes only.
"""Langfuse observability client for tracing runs, spans, and generations."""

from __future__ import annotations

import functools
from contextlib import contextmanager
from contextvars import ContextVar
from typing import Any, Callable, Generator, Optional

from app.config import settings

_langfuse_client = None

# Context for the current CLI run / async task
_current_trace_id: ContextVar[Optional[str]] = ContextVar("_current_trace_id", default=None)
_current_run_id: ContextVar[Optional[str]] = ContextVar("_current_run_id", default=None)
_current_agent: ContextVar[Optional[str]] = ContextVar("_current_agent", default=None)
_current_operation_type: ContextVar[Optional[str]] = ContextVar("_current_operation_type", default=None)


def get_langfuse():
    global _langfuse_client
    if _langfuse_client is None and settings.langfuse_secret_key and settings.langfuse_public_key:
        try:
            from langfuse import Langfuse  # type: ignore

            _langfuse_client = Langfuse(
                secret_key=settings.langfuse_secret_key,
                public_key=settings.langfuse_public_key,
                host=settings.langfuse_host,
            )
        except ImportError:
            print("Warning: langfuse package not installed")
        except Exception as e:
            print(f"Warning: Failed to initialize Langfuse: {e}")
    return _langfuse_client


def set_run_context(*, run_id: str, trace_id: str, agent: str | None = None, operation_type: str | None = None) -> None:
    _current_run_id.set(run_id)
    _current_trace_id.set(trace_id)
    if agent is not None:
        _current_agent.set(agent)
    if operation_type is not None:
        _current_operation_type.set(operation_type)


def set_node_context(*, agent: str, operation_type: str) -> None:
    _current_agent.set(agent)
    _current_operation_type.set(operation_type)


def get_trace_id() -> Optional[str]:
    return _current_trace_id.get()


def start_run_trace(*, run_id: str, name: str, user_id: Optional[str] = None, metadata: Optional[dict] = None) -> Optional[str]:
    """
    Creates ONE trace for the whole CLI run. Call once per run_id.
    Returns trace_id (string) or None if disabled.
    """
    langfuse = get_langfuse()
    if langfuse is None:
        return None

    trace = langfuse.trace(
        id=str(run_id),
        name=name,
        user_id=user_id,
        metadata={"run_id": run_id, **(metadata or {})},
    )
    set_run_context(run_id=str(run_id), trace_id=str(run_id))
    return str(run_id)


@contextmanager
def trace_span(name: str, input: Optional[dict] = None, metadata: Optional[dict] = None) -> Generator:
    """
    Creates a span under the current run trace (must have called start_run_trace()).
    """
    langfuse = get_langfuse()
    trace_id = get_trace_id()
    if langfuse is None or not trace_id:
        yield None
        return

    trace = langfuse.trace(id=trace_id)
    span = trace.span(
        name=name,
        input=input or {},
        metadata={
            "run_id": _current_run_id.get(),
            "agent": _current_agent.get(),
            "operation_type": _current_operation_type.get(),
            **(metadata or {}),
        },
    )

    try:
        yield span
        span.end(status="success")
    except Exception as e:
        span.end(status="error", output={"error": str(e)})
        raise


def log_generation(
    *,
    name: str,
    model: str,
    prompt: Any,
    completion: Any,
    tokens_input: int = 0,
    tokens_output: int = 0,
    metadata: Optional[dict] = None,
) -> None:
    """
    Logs a generation under the current run trace.
    Call this from your SINGLE LLM wrapper.
    """
    langfuse = get_langfuse()
    trace_id = get_trace_id()
    if langfuse is None or not trace_id:
        return

    trace = langfuse.trace(id=trace_id)
    trace.generation(
        name=name,
        model=model,
        input=prompt,
        output=completion,
        metadata={
            "run_id": _current_run_id.get(),
            "agent": _current_agent.get(),
            "operation_type": _current_operation_type.get(),
            "prompt_tokens": tokens_input,
            "completion_tokens": tokens_output,
            "total_tokens": (tokens_input or 0) + (tokens_output or 0),
            **(metadata or {}),
        },
    )


def observe(name: Optional[str] = None, metadata: Optional[dict] = None) -> Callable:
    """
    Decorator that creates a span under the current run trace.
    Use only after start_run_trace() has been called.
    """
    def decorator(func: Callable) -> Callable:
        trace_name = name or func.__name__

        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs) -> Any:
            with trace_span(name=f"fn:{trace_name}", metadata=metadata):
                return await func(*args, **kwargs)

        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs) -> Any:
            with trace_span(name=f"fn:{trace_name}", metadata=metadata):
                return func(*args, **kwargs)

        import asyncio
        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper

    return decorator


def flush_langfuse() -> None:
    langfuse = get_langfuse()
    if langfuse:
        langfuse.flush()


def shutdown_langfuse() -> None:
    global _langfuse_client
    if _langfuse_client:
        _langfuse_client.flush()
        _langfuse_client.shutdown()
        _langfuse_client = None
